"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-multiline-string
const chai_1 = require("chai");
const fs = require("fs");
const path = require("path");
const ts = require("typescript");
const testFilename = path.join(__dirname, "..", "test.ts");
function getDiagnostics(code) {
    fs.writeFileSync(testFilename, code);
    const options = {
        module: ts.ModuleKind.CommonJS,
        sourceMap: false,
        target: ts.ScriptTarget.ES2017,
        experimentalDecorators: true,
        strict: true,
        strictPropertyInitialization: false,
        noUnusedLocals: true,
        emitDecoratorMetadata: true,
        skipLibCheck: true,
        outDir: "build",
        noUnusedParameters: true,
        inlineSourceMap: true,
        inlineSources: true,
        noImplicitReturns: true,
        noImplicitThis: true,
        declaration: true,
    };
    const program = ts.createProgram([testFilename], options);
    const emitResult = program.emit();
    const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
    return allDiagnostics;
}
describe("compile time typed-knex string column parameters", function () {
    this.timeout(1000000);
    afterEach(() => {
        try {
            fs.unlinkSync(testFilename);
            // tslint:disable-next-line: no-empty
        }
        catch (_e) { }
    });
    it("should return type with properties from the selectColumn method", (done) => {
        const allDiagnostics = getDiagnostics(`
        import { knex} from 'knex';

        import { TypedKnex } from '../src/typedKnex';
        import { User } from './testEntities';


        (async () => {

            const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
            const result = await typedKnex
                .query(User)
                .select('id')
                .getFirst();

            console.log(result.id);

        })();
    `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling property not used in selectColumn method", (done) => {
        const allDiagnostics = getDiagnostics(`
        import { knex} from 'knex';

        import { TypedKnex } from '../src/typedKnex';
        import { User } from './testEntities';


        (async () => {

            const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
            const result = await typedKnex
                .query(User)
                .select('id')
                .getFirst();

            console.log(result.name);

        })();
    `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should return type with properties from the select method", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .select('id')
                    .getFirst();

                console.log(result.id);

            })();
            `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling property not used in select method", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .select('id')
                    .getFirst();

                console.log(result.name);

            })();
            `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should allow to call whereIn with type of property", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const query = typedKnex
                .query(User)
                .whereIn('name', ['user1', 'user2']);


            })();
            `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling whereIn with different type", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const query = typedKnex
                .query(User)
                .whereIn('name', [1]);

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should allow to call whereBetween with type of property", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const query = typedKnex
                .query(User)
                .whereBetween('numericValue', [1,10]);


            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling whereBetween with different type", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const query = typedKnex
                .query(User)
                .whereBetween('numericValue', ['','']);

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling whereBetween with array of more than 2", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const query = typedKnex
                .query(User)
                .whereBetween('numericValue', [1,2,3]);

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should allow property of parent query in where exists", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const query = typedKnex
                .query(User)
                .whereExists(UserSetting, (subQuery) => {

                    subQuery.whereColumns('user.id', '=', 'someValue');
                });


            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should not allow unknown property of parent query in where exists", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const query = typedKnex
                .query(User)
                .whereExists(UserSetting, (subQuery) => {

                    subQuery.whereColumns('user.id', '=', 'unknown');
                });


            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should return type with properties from the min method", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .min('numericValue', 'minNumericValue')
                    .getFirst();

                console.log(result.minNumericValue);

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should error on calling property not used in min method", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .min('numericValue', 'minNumericValue')
                    .getFirst();

                console.log(result.id);

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should return all Model properties after clearSelect", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .select('id')
                    .clearSelect()
                    .getFirst();

                    console.log(result.id);
                    console.log(result.name);

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    // it('should return correct type from findByColumn', done => {
    //     file = project.createSourceFile(
    //         'test/test4.ts',
    //         `
    //         import { knex} from 'knex';
    //         import { TypedKnex } from '../src/typedKnex';
    //         import { User } from './testEntities';
    //         (async () => {
    //             const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
    //             const item = await typedKnex
    //             .query(User)
    //             .findByColumn('numericValue', 1, 'name');
    //             if (item !== undefined) {
    //                 console.log(item.name);
    //             }
    //         })();
    //     `
    //     );
    //     assert.equal(allDiagnostics.length, 0);
    //     done();
    // });
    it("should return correct type from findByPrimaryKey", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'name');

                if (item !== undefined) {
                    console.log(item.name);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey not accept objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'category');

                if (item !== undefined) {
                    console.log(item.category);
                }

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey not accept optional objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'optionalCategory');

                if (item !== undefined) {
                    console.log(item.optionalCategory);
                }

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey not accept nullable objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'nullableCategory');

                if (item !== undefined) {
                    console.log(item.nullableCategory);
                }

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey accept Date objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'birthDate');

                if (item !== undefined) {
                    console.log(item.birthDate);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey accept unknown objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'extraData');

                if (item !== undefined) {
                    console.log(item.extraData);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey accept nullable Date objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'deathDate');

                if (item !== undefined) {
                    console.log(item.deathDate);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey accept nullable string objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'someNullableValue');

                if (item !== undefined) {
                    console.log(item.someNullableValue);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should findByPrimaryKey accept optional string objects in select", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(User)
                .findByPrimaryKey("id", 'someOptionalValue');

                if (item !== undefined) {
                    console.log(item.someOptionalValue);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should return correct type from leftOuterJoinTableOnFunction", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(UserSetting)
                .leftOuterJoinTableOnFunction('otherUser', User, join => {
                    join.on('id', '=', 'user2Id');
                })
                .select('otherUser.name', 'user2.numericValue')
                .getFirst();

                if (item !== undefined) {
                    console.log(item.user2.numericValue);
                    console.log(item.otherUser.name);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should not return type from leftOuterJoinTableOnFunction with not selected from joined table", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(UserSetting)
                .leftOuterJoinTableOnFunction('otherUser', User, join => {
                    join.on('id', '=', 'user2Id');
                })
                .select('otherUser.name', 'user2.numericValue')
                .getFirst();

                if (item !== undefined) {
                    console.log(item.otherUser.id);
                }

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should not return type from leftOuterJoinTableOnFunction with not selected from main table", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(UserSetting)
                .leftOuterJoinTableOnFunction('otherUser', User, join => {
                    join.on('id', '=', 'user2Id');
                })
                .select('otherUser.name', 'user2.numericValue')
                .getFirst();

                if (item !== undefined) {
                    console.log(item.id);
                }

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should  return any when keepFlat() is used", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(UserSetting)
                .leftOuterJoinTableOnFunction('otherUser', User, join => {
                    join.on('id', '=', 'user2Id');
                })
                .select('otherUser.name', 'user2.numericValue')
                .keepFlat()
                .getSingle();


                console.log(item.doesNotExist);


            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should accept string column in orderBy", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .orderBy('id')
                    .getMany();

                console.log(result.length);

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should accept Date column in orderBy", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .orderBy('birthDate')
                    .getMany();

                console.log(result.length);

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should accept nullable Date column in orderBy", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .orderBy('deathDate')
                    .getMany();

                console.log(result.length);

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should not accept foreign key column in orderBy", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
                const result = await typedKnex
                    .query(User)
                    .orderBy(c=>c.category)
                    .getMany();

                console.log(result.length);

            })();
        `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
    it("should return correct type from nested left outer join", (done) => {
        const allDiagnostics = getDiagnostics(`
            import { knex} from 'knex';

            import { TypedKnex } from '../src/typedKnex';
            import { User, UserSetting } from './testEntities';


            (async () => {

                const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));

                const item = await typedKnex
                .query(UserSetting)
                .leftOuterJoin('otherUser', User, 'status', '=', 'otherValue')
                .leftOuterJoin('otherUser.otherOtherUser', User, 'status', '=', 'otherUser.status')
                .select('otherUser.otherOtherUser.name')
                .getFirst();

                if (item !== undefined) {
                    console.log(item.otherUser.otherOtherUser.name);
                }

            })();
        `);
        chai_1.assert.equal(allDiagnostics.length, 0);
        done();
    });
    it("should fail if result of getSingleOrNull of query without select is used as object", (done) => {
        const allDiagnostics = getDiagnostics(`
        import { knex} from 'knex';

        import { TypedKnex } from '../src/typedKnex';
        import { User } from './testEntities';


        (async () => {

            const typedKnex = new TypedKnex(knex({ client: 'postgresql' }));
            const result = await typedKnex
                .query(User)
                .getSingleOrNull();

            // result is User|null and this should fail
            console.log(result.id);

        })();
    `);
        chai_1.assert.notEqual(allDiagnostics.length, 0);
        done();
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsYXRpb25UZXN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvY29tcGlsYXRpb24vY29tcGlsYXRpb25UZXN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFDQUFxQztBQUNyQywrQkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFFakMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBRTNELFNBQVMsY0FBYyxDQUFDLElBQVk7SUFDaEMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFFckMsTUFBTSxPQUFPLEdBQXVCO1FBQ2hDLE1BQU0sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVE7UUFDOUIsU0FBUyxFQUFFLEtBQUs7UUFDaEIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTTtRQUM5QixzQkFBc0IsRUFBRSxJQUFJO1FBQzVCLE1BQU0sRUFBRSxJQUFJO1FBQ1osNEJBQTRCLEVBQUUsS0FBSztRQUNuQyxjQUFjLEVBQUUsSUFBSTtRQUNwQixxQkFBcUIsRUFBRSxJQUFJO1FBQzNCLFlBQVksRUFBRSxJQUFJO1FBQ2xCLE1BQU0sRUFBRSxPQUFPO1FBQ2Ysa0JBQWtCLEVBQUUsSUFBSTtRQUN4QixlQUFlLEVBQUUsSUFBSTtRQUNyQixhQUFhLEVBQUUsSUFBSTtRQUNuQixpQkFBaUIsRUFBRSxJQUFJO1FBQ3ZCLGNBQWMsRUFBRSxJQUFJO1FBQ3BCLFdBQVcsRUFBRSxJQUFJO0tBQ3BCLENBQUM7SUFFRixNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUQsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0lB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SUFDWCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyx3REFBd0QsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2xFLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0F1QnJDLENBQUMsQ0FBQztRQUNILGFBQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUV2QyxJQUFJLEVBQUUsQ0FBQztJQUNYLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLG9GQUFvRixFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDOUYsTUFBTSxjQUFjLEdBQUcsY0FBYyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrQnpDLENBQUMsQ0FBQztRQUVDLGFBQU0sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUxQyxJQUFJLEVBQUUsQ0FBQztJQUNYLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTpuby1tdWx0aWxpbmUtc3RyaW5nXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyB0cyBmcm9tIFwidHlwZXNjcmlwdFwiO1xuXG5jb25zdCB0ZXN0RmlsZW5hbWUgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwidGVzdC50c1wiKTtcblxuZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY3MoY29kZTogc3RyaW5nKSB7XG4gICAgZnMud3JpdGVGaWxlU3luYyh0ZXN0RmlsZW5hbWUsIGNvZGUpO1xuXG4gICAgY29uc3Qgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zID0ge1xuICAgICAgICBtb2R1bGU6IHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gICAgICAgIHNvdXJjZU1hcDogZmFsc2UsXG4gICAgICAgIHRhcmdldDogdHMuU2NyaXB0VGFyZ2V0LkVTMjAxNyxcbiAgICAgICAgZXhwZXJpbWVudGFsRGVjb3JhdG9yczogdHJ1ZSxcbiAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICBzdHJpY3RQcm9wZXJ0eUluaXRpYWxpemF0aW9uOiBmYWxzZSxcbiAgICAgICAgbm9VbnVzZWRMb2NhbHM6IHRydWUsXG4gICAgICAgIGVtaXREZWNvcmF0b3JNZXRhZGF0YTogdHJ1ZSxcbiAgICAgICAgc2tpcExpYkNoZWNrOiB0cnVlLFxuICAgICAgICBvdXREaXI6IFwiYnVpbGRcIixcbiAgICAgICAgbm9VbnVzZWRQYXJhbWV0ZXJzOiB0cnVlLFxuICAgICAgICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXG4gICAgICAgIGlubGluZVNvdXJjZXM6IHRydWUsXG4gICAgICAgIG5vSW1wbGljaXRSZXR1cm5zOiB0cnVlLFxuICAgICAgICBub0ltcGxpY2l0VGhpczogdHJ1ZSxcbiAgICAgICAgZGVjbGFyYXRpb246IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0cy5jcmVhdGVQcm9ncmFtKFt0ZXN0RmlsZW5hbWVdLCBvcHRpb25zKTtcbiAgICBjb25zdCBlbWl0UmVzdWx0ID0gcHJvZ3JhbS5lbWl0KCk7XG5cbiAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IHRzLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKS5jb25jYXQoZW1pdFJlc3VsdC5kaWFnbm9zdGljcyk7XG5cbiAgICByZXR1cm4gYWxsRGlhZ25vc3RpY3M7XG59XG5cbmRlc2NyaWJlKFwiY29tcGlsZSB0aW1lIHR5cGVkLWtuZXggc3RyaW5nIGNvbHVtbiBwYXJhbWV0ZXJzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRpbWVvdXQoMTAwMDAwMCk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMudW5saW5rU3luYyh0ZXN0RmlsZW5hbWUpO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIChfZSkge31cbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiB0eXBlIHdpdGggcHJvcGVydGllcyBmcm9tIHRoZSBzZWxlY3RDb2x1bW4gbWV0aG9kXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgICAgICAuZ2V0Rmlyc3QoKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmlkKTtcblxuICAgICAgICB9KSgpO1xuICAgIGApO1xuXG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGVycm9yIG9uIGNhbGxpbmcgcHJvcGVydHkgbm90IHVzZWQgaW4gc2VsZWN0Q29sdW1uIG1ldGhvZFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgICAgICAgLmdldEZpcnN0KCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5uYW1lKTtcblxuICAgICAgICB9KSgpO1xuICAgIGApO1xuXG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiB0eXBlIHdpdGggcHJvcGVydGllcyBmcm9tIHRoZSBzZWxlY3QgbWV0aG9kXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0Rmlyc3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5pZCk7XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBgKTtcblxuICAgICAgICBhc3NlcnQuZXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBlcnJvciBvbiBjYWxsaW5nIHByb3BlcnR5IG5vdCB1c2VkIGluIHNlbGVjdCBtZXRob2RcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRGaXJzdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0Lm5hbWUpO1xuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgYCk7XG5cbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWxsb3cgdG8gY2FsbCB3aGVyZUluIHdpdGggdHlwZSBvZiBwcm9wZXJ0eVwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC53aGVyZUluKCduYW1lJywgWyd1c2VyMScsICd1c2VyMiddKTtcblxuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgYCk7XG5cbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZXJyb3Igb24gY2FsbGluZyB3aGVyZUluIHdpdGggZGlmZmVyZW50IHR5cGVcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC53aGVyZUluKCduYW1lJywgWzFdKTtcblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGFsbG93IHRvIGNhbGwgd2hlcmVCZXR3ZWVuIHdpdGggdHlwZSBvZiBwcm9wZXJ0eVwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC53aGVyZUJldHdlZW4oJ251bWVyaWNWYWx1ZScsIFsxLDEwXSk7XG5cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGVycm9yIG9uIGNhbGxpbmcgd2hlcmVCZXR3ZWVuIHdpdGggZGlmZmVyZW50IHR5cGVcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC53aGVyZUJldHdlZW4oJ251bWVyaWNWYWx1ZScsIFsnJywnJ10pO1xuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZXJyb3Igb24gY2FsbGluZyB3aGVyZUJldHdlZW4gd2l0aCBhcnJheSBvZiBtb3JlIHRoYW4gMlwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgLndoZXJlQmV0d2VlbignbnVtZXJpY1ZhbHVlJywgWzEsMiwzXSk7XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQubm90RXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBhbGxvdyBwcm9wZXJ0eSBvZiBwYXJlbnQgcXVlcnkgaW4gd2hlcmUgZXhpc3RzXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciwgVXNlclNldHRpbmcgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgLndoZXJlRXhpc3RzKFVzZXJTZXR0aW5nLCAoc3ViUXVlcnkpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBzdWJRdWVyeS53aGVyZUNvbHVtbnMoJ3VzZXIuaWQnLCAnPScsICdzb21lVmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbm90IGFsbG93IHVua25vd24gcHJvcGVydHkgb2YgcGFyZW50IHF1ZXJ5IGluIHdoZXJlIGV4aXN0c1wiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIsIFVzZXJTZXR0aW5nIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC53aGVyZUV4aXN0cyhVc2VyU2V0dGluZywgKHN1YlF1ZXJ5KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3ViUXVlcnkud2hlcmVDb2x1bW5zKCd1c2VyLmlkJywgJz0nLCAndW5rbm93bicpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQubm90RXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXR1cm4gdHlwZSB3aXRoIHByb3BlcnRpZXMgZnJvbSB0aGUgbWluIG1ldGhvZFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgICAgIC5taW4oJ251bWVyaWNWYWx1ZScsICdtaW5OdW1lcmljVmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0Rmlyc3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5taW5OdW1lcmljVmFsdWUpO1xuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZXJyb3Igb24gY2FsbGluZyBwcm9wZXJ0eSBub3QgdXNlZCBpbiBtaW4gbWV0aG9kXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAgICAgLm1pbignbnVtZXJpY1ZhbHVlJywgJ21pbk51bWVyaWNWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRGaXJzdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmlkKTtcblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiBhbGwgTW9kZWwgcHJvcGVydGllcyBhZnRlciBjbGVhclNlbGVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgICAgICAgICAgLmNsZWFyU2VsZWN0KClcbiAgICAgICAgICAgICAgICAgICAgLmdldEZpcnN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0Lm5hbWUpO1xuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gaXQoJ3Nob3VsZCByZXR1cm4gY29ycmVjdCB0eXBlIGZyb20gZmluZEJ5Q29sdW1uJywgZG9uZSA9PiB7XG4gICAgLy8gICAgIGZpbGUgPSBwcm9qZWN0LmNyZWF0ZVNvdXJjZUZpbGUoXG4gICAgLy8gICAgICAgICAndGVzdC90ZXN0NC50cycsXG4gICAgLy8gICAgICAgICBgXG4gICAgLy8gICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgIC8vICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgLy8gICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG4gICAgLy8gICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgLy8gICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuXG4gICAgLy8gICAgICAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHR5cGVkS25leFxuICAgIC8vICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgIC8vICAgICAgICAgICAgIC5maW5kQnlDb2x1bW4oJ251bWVyaWNWYWx1ZScsIDEsICduYW1lJyk7XG5cbiAgICAvLyAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0ubmFtZSk7XG4gICAgLy8gICAgICAgICAgICAgfVxuXG4gICAgLy8gICAgICAgICB9KSgpO1xuICAgIC8vICAgICBgXG4gICAgLy8gICAgICk7XG5cbiAgICAvLyAgICAgYXNzZXJ0LmVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmV0dXJuIGNvcnJlY3QgdHlwZSBmcm9tIGZpbmRCeVByaW1hcnlLZXlcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgLmZpbmRCeVByaW1hcnlLZXkoXCJpZFwiLCAnbmFtZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZpbmRCeVByaW1hcnlLZXkgbm90IGFjY2VwdCBvYmplY3RzIGluIHNlbGVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuZmluZEJ5UHJpbWFyeUtleShcImlkXCIsICdjYXRlZ29yeScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLmNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQubm90RXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBmaW5kQnlQcmltYXJ5S2V5IG5vdCBhY2NlcHQgb3B0aW9uYWwgb2JqZWN0cyBpbiBzZWxlY3RcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgLmZpbmRCeVByaW1hcnlLZXkoXCJpZFwiLCAnb3B0aW9uYWxDYXRlZ29yeScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLm9wdGlvbmFsQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZpbmRCeVByaW1hcnlLZXkgbm90IGFjY2VwdCBudWxsYWJsZSBvYmplY3RzIGluIHNlbGVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuZmluZEJ5UHJpbWFyeUtleShcImlkXCIsICdudWxsYWJsZUNhdGVnb3J5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0ubnVsbGFibGVDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZmluZEJ5UHJpbWFyeUtleSBhY2NlcHQgRGF0ZSBvYmplY3RzIGluIHNlbGVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuZmluZEJ5UHJpbWFyeUtleShcImlkXCIsICdiaXJ0aERhdGUnKTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbS5iaXJ0aERhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZpbmRCeVByaW1hcnlLZXkgYWNjZXB0IHVua25vd24gb2JqZWN0cyBpbiBzZWxlY3RcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgLmZpbmRCeVByaW1hcnlLZXkoXCJpZFwiLCAnZXh0cmFEYXRhJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0uZXh0cmFEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQuZXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBmaW5kQnlQcmltYXJ5S2V5IGFjY2VwdCBudWxsYWJsZSBEYXRlIG9iamVjdHMgaW4gc2VsZWN0XCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC5maW5kQnlQcmltYXJ5S2V5KFwiaWRcIiwgJ2RlYXRoRGF0ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLmRlYXRoRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZmluZEJ5UHJpbWFyeUtleSBhY2NlcHQgbnVsbGFibGUgc3RyaW5nIG9iamVjdHMgaW4gc2VsZWN0XCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgIC5maW5kQnlQcmltYXJ5S2V5KFwiaWRcIiwgJ3NvbWVOdWxsYWJsZVZhbHVlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0uc29tZU51bGxhYmxlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZpbmRCeVByaW1hcnlLZXkgYWNjZXB0IG9wdGlvbmFsIHN0cmluZyBvYmplY3RzIGluIHNlbGVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuZmluZEJ5UHJpbWFyeUtleShcImlkXCIsICdzb21lT3B0aW9uYWxWYWx1ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLnNvbWVPcHRpb25hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQuZXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXR1cm4gY29ycmVjdCB0eXBlIGZyb20gbGVmdE91dGVySm9pblRhYmxlT25GdW5jdGlvblwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIsIFVzZXJTZXR0aW5nIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXJTZXR0aW5nKVxuICAgICAgICAgICAgICAgIC5sZWZ0T3V0ZXJKb2luVGFibGVPbkZ1bmN0aW9uKCdvdGhlclVzZXInLCBVc2VyLCBqb2luID0+IHtcbiAgICAgICAgICAgICAgICAgICAgam9pbi5vbignaWQnLCAnPScsICd1c2VyMklkJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdvdGhlclVzZXIubmFtZScsICd1c2VyMi5udW1lcmljVmFsdWUnKVxuICAgICAgICAgICAgICAgIC5nZXRGaXJzdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLnVzZXIyLm51bWVyaWNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0ub3RoZXJVc2VyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG5vdCByZXR1cm4gdHlwZSBmcm9tIGxlZnRPdXRlckpvaW5UYWJsZU9uRnVuY3Rpb24gd2l0aCBub3Qgc2VsZWN0ZWQgZnJvbSBqb2luZWQgdGFibGVcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyLCBVc2VyU2V0dGluZyB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyU2V0dGluZylcbiAgICAgICAgICAgICAgICAubGVmdE91dGVySm9pblRhYmxlT25GdW5jdGlvbignb3RoZXJVc2VyJywgVXNlciwgam9pbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGpvaW4ub24oJ2lkJywgJz0nLCAndXNlcjJJZCcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnb3RoZXJVc2VyLm5hbWUnLCAndXNlcjIubnVtZXJpY1ZhbHVlJylcbiAgICAgICAgICAgICAgICAuZ2V0Rmlyc3QoKTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbS5vdGhlclVzZXIuaWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG5vdCByZXR1cm4gdHlwZSBmcm9tIGxlZnRPdXRlckpvaW5UYWJsZU9uRnVuY3Rpb24gd2l0aCBub3Qgc2VsZWN0ZWQgZnJvbSBtYWluIHRhYmxlXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciwgVXNlclNldHRpbmcgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlclNldHRpbmcpXG4gICAgICAgICAgICAgICAgLmxlZnRPdXRlckpvaW5UYWJsZU9uRnVuY3Rpb24oJ290aGVyVXNlcicsIFVzZXIsIGpvaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBqb2luLm9uKCdpZCcsICc9JywgJ3VzZXIySWQnKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ290aGVyVXNlci5uYW1lJywgJ3VzZXIyLm51bWVyaWNWYWx1ZScpXG4gICAgICAgICAgICAgICAgLmdldEZpcnN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5ub3RFcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkICByZXR1cm4gYW55IHdoZW4ga2VlcEZsYXQoKSBpcyB1c2VkXCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciwgVXNlclNldHRpbmcgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlclNldHRpbmcpXG4gICAgICAgICAgICAgICAgLmxlZnRPdXRlckpvaW5UYWJsZU9uRnVuY3Rpb24oJ290aGVyVXNlcicsIFVzZXIsIGpvaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBqb2luLm9uKCdpZCcsICc9JywgJ3VzZXIySWQnKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ290aGVyVXNlci5uYW1lJywgJ3VzZXIyLm51bWVyaWNWYWx1ZScpXG4gICAgICAgICAgICAgICAgLmtlZXBGbGF0KClcbiAgICAgICAgICAgICAgICAuZ2V0U2luZ2xlKCk7XG5cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0uZG9lc05vdEV4aXN0KTtcblxuXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICBgKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGFsbERpYWdub3N0aWNzLmxlbmd0aCwgMCk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWNjZXB0IHN0cmluZyBjb2x1bW4gaW4gb3JkZXJCeVwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS25leCA9IG5ldyBUeXBlZEtuZXgoa25leCh7IGNsaWVudDogJ3Bvc3RncmVzcWwnIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXIpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlckJ5KCdpZCcpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRNYW55KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGFjY2VwdCBEYXRlIGNvbHVtbiBpbiBvcmRlckJ5XCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAgICAgLm9yZGVyQnkoJ2JpcnRoRGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRNYW55KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGFjY2VwdCBudWxsYWJsZSBEYXRlIGNvbHVtbiBpbiBvcmRlckJ5XCIsIChkb25lKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbERpYWdub3N0aWNzID0gZ2V0RGlhZ25vc3RpY3MoYFxuICAgICAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgICAgIGltcG9ydCB7IFR5cGVkS25leCB9IGZyb20gJy4uL3NyYy90eXBlZEtuZXgnO1xuICAgICAgICAgICAgaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdGVzdEVudGl0aWVzJztcblxuXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLbmV4ID0gbmV3IFR5cGVkS25leChrbmV4KHsgY2xpZW50OiAncG9zdGdyZXNxbCcgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR5cGVkS25leFxuICAgICAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAgICAgLm9yZGVyQnkoJ2RlYXRoRGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRNYW55KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG5vdCBhY2NlcHQgZm9yZWlnbiBrZXkgY29sdW1uIGluIG9yZGVyQnlcIiwgKGRvbmUpID0+IHtcbiAgICAgICAgY29uc3QgYWxsRGlhZ25vc3RpY3MgPSBnZXREaWFnbm9zdGljcyhgXG4gICAgICAgICAgICBpbXBvcnQgeyBrbmV4fSBmcm9tICdrbmV4JztcblxuICAgICAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgICAgICBpbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeShVc2VyKVxuICAgICAgICAgICAgICAgICAgICAub3JkZXJCeShjPT5jLmNhdGVnb3J5KVxuICAgICAgICAgICAgICAgICAgICAuZ2V0TWFueSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0Lmxlbmd0aCk7XG5cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGApO1xuICAgICAgICBhc3NlcnQubm90RXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXR1cm4gY29ycmVjdCB0eXBlIGZyb20gbmVzdGVkIGxlZnQgb3V0ZXIgam9pblwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgICAgIGltcG9ydCB7IGtuZXh9IGZyb20gJ2tuZXgnO1xuXG4gICAgICAgICAgICBpbXBvcnQgeyBUeXBlZEtuZXggfSBmcm9tICcuLi9zcmMvdHlwZWRLbmV4JztcbiAgICAgICAgICAgIGltcG9ydCB7IFVzZXIsIFVzZXJTZXR0aW5nIH0gZnJvbSAnLi90ZXN0RW50aXRpZXMnO1xuXG5cbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYXdhaXQgdHlwZWRLbmV4XG4gICAgICAgICAgICAgICAgLnF1ZXJ5KFVzZXJTZXR0aW5nKVxuICAgICAgICAgICAgICAgIC5sZWZ0T3V0ZXJKb2luKCdvdGhlclVzZXInLCBVc2VyLCAnc3RhdHVzJywgJz0nLCAnb3RoZXJWYWx1ZScpXG4gICAgICAgICAgICAgICAgLmxlZnRPdXRlckpvaW4oJ290aGVyVXNlci5vdGhlck90aGVyVXNlcicsIFVzZXIsICdzdGF0dXMnLCAnPScsICdvdGhlclVzZXIuc3RhdHVzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdvdGhlclVzZXIub3RoZXJPdGhlclVzZXIubmFtZScpXG4gICAgICAgICAgICAgICAgLmdldEZpcnN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0ub3RoZXJVc2VyLm90aGVyT3RoZXJVc2VyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgYCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChhbGxEaWFnbm9zdGljcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZhaWwgaWYgcmVzdWx0IG9mIGdldFNpbmdsZU9yTnVsbCBvZiBxdWVyeSB3aXRob3V0IHNlbGVjdCBpcyB1c2VkIGFzIG9iamVjdFwiLCAoZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGdldERpYWdub3N0aWNzKGBcbiAgICAgICAgaW1wb3J0IHsga25leH0gZnJvbSAna25leCc7XG5cbiAgICAgICAgaW1wb3J0IHsgVHlwZWRLbmV4IH0gZnJvbSAnLi4vc3JjL3R5cGVkS25leCc7XG4gICAgICAgIGltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3Rlc3RFbnRpdGllcyc7XG5cblxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB0eXBlZEtuZXggPSBuZXcgVHlwZWRLbmV4KGtuZXgoeyBjbGllbnQ6ICdwb3N0Z3Jlc3FsJyB9KSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eXBlZEtuZXhcbiAgICAgICAgICAgICAgICAucXVlcnkoVXNlcilcbiAgICAgICAgICAgICAgICAuZ2V0U2luZ2xlT3JOdWxsKCk7XG5cbiAgICAgICAgICAgIC8vIHJlc3VsdCBpcyBVc2VyfG51bGwgYW5kIHRoaXMgc2hvdWxkIGZhaWxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5pZCk7XG5cbiAgICAgICAgfSkoKTtcbiAgICBgKTtcblxuICAgICAgICBhc3NlcnQubm90RXF1YWwoYWxsRGlhZ25vc3RpY3MubGVuZ3RoLCAwKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG59KTtcbiJdfQ==